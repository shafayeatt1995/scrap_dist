{"version":3,"sources":["webpack:///./node_modules/image-meta/dist/index.cjs"],"names":["Object","defineProperty","exports","value","BMP","validate","buffer","toString","calculate","height","Math","abs","readInt32LE","width","readUInt32LE","getSizeFromOffset","offset","readUInt8","getImageSize$1","imageIndex","ICO","readUInt16LE","nbImages","imageSize","imgs","push","images","CUR","DDS","gifRegexp","GIF","signature","test","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","imageOffset","imageLengthOffset","readUInt32BE","getImageSize","type","size","ICNS","bufferLength","length","fileLength","imageHeader","result","J2C","BoxTypes","parseIHDR","box","JP2","signatureLength","ftypeBoxStart","ftypBoxLength","slice","readUInt16BE","unit","calculateRREQLength","TypeError","readUInt","bits","isBigEndian","call","EXIF_HEADER_BYTES","IDF_ENTRY_BYTES","NUM_DIRECTORY_ENTRIES_BYTES","isEXIF","extractSize","index","validateExifBlock","exifBlock","byteAlign","idfDirectoryEntries","directoryEntryNumber","start","end","block","extractOrientation","validateBuffer","JPG","orientation","next","i","KTX","pngFriedChunkName","PNG","chunkName","PNMTypes","P1","P2","P3","P4","P5","P6","P7","PF","Signatures","keys","handlers","default","lines","dimensions","line","shift","split","parseInt","pam","charCodeAt","key","toLowerCase","svgReg","extractorRegExps","root","viewbox","INCH_CM","units","cm","em","ex","m","mm","pc","pt","parseLength","len","exec","round","parseFloat","parseViewbox","bounds","typeHandlers","bmp","cur","dds","gif","icns","ico","j2c","jp2","jpg","ktx","png","pnm","includes","psd","svg","str","String","match","attrs","parseAttributes","calculateByDimensions","ratio","floor","calculateByViewbox","webp","riffHeader","webpHeader","vp8Header","chunkHeader","extendedHeader","readUIntLE","calculateExtended","readInt16LE","calculateLossy","calculateLossless","getMimeType","firstBytes","lookup","filepath","byte","find","detector","mimeType","types","imageMeta","input","Buffer","isBuffer","Error"],"mappings":"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","file":"f35345b.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst BMP = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 2) === \"BM\";\n  },\n  calculate(buffer) {\n    return {\n      height: Math.abs(buffer.readInt32LE(22)),\n      width: buffer.readUInt32LE(18)\n    };\n  }\n};\n\nconst TYPE_ICON = 1;\nconst SIZE_HEADER$1 = 2 + 2 + 2;\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;\nfunction getSizeFromOffset(buffer, offset) {\n  const value = buffer.readUInt8(offset);\n  return value === 0 ? 256 : value;\n}\nfunction getImageSize$1(buffer, imageIndex) {\n  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;\n  return {\n    height: getSizeFromOffset(buffer, offset + 1),\n    width: getSizeFromOffset(buffer, offset)\n  };\n}\nconst ICO = {\n  validate(buffer) {\n    if (buffer.readUInt16LE(0) !== 0) {\n      return false;\n    }\n    return buffer.readUInt16LE(2) === TYPE_ICON;\n  },\n  calculate(buffer) {\n    const nbImages = buffer.readUInt16LE(4);\n    const imageSize = getImageSize$1(buffer, 0);\n    if (nbImages === 1) {\n      return imageSize;\n    }\n    const imgs = [imageSize];\n    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n      imgs.push(getImageSize$1(buffer, imageIndex));\n    }\n    const result = {\n      height: imageSize.height,\n      images: imgs,\n      width: imageSize.width\n    };\n    return result;\n  }\n};\n\nconst TYPE_CURSOR = 2;\nconst CUR = {\n  validate(buffer) {\n    if (buffer.readUInt16LE(0) !== 0) {\n      return false;\n    }\n    return buffer.readUInt16LE(2) === TYPE_CURSOR;\n  },\n  calculate(buffer) {\n    return ICO.calculate(buffer);\n  }\n};\n\nconst DDS = {\n  validate(buffer) {\n    return buffer.readUInt32LE(0) === 542327876;\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32LE(12),\n      width: buffer.readUInt32LE(16)\n    };\n  }\n};\n\nconst gifRegexp = /^GIF8[79]a/;\nconst GIF = {\n  validate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 6);\n    return gifRegexp.test(signature);\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt16LE(8),\n      width: buffer.readUInt16LE(6)\n    };\n  }\n};\n\nconst SIZE_HEADER = 4 + 4;\nconst FILE_LENGTH_OFFSET = 4;\nconst ENTRY_LENGTH_OFFSET = 4;\nconst ICON_TYPE_SIZE = {\n  ICON: 32,\n  \"ICN#\": 32,\n  \"icm#\": 16,\n  icm4: 16,\n  icm8: 16,\n  \"ics#\": 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  icp6: 64,\n  ic12: 32,\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  ic08: 256,\n  ic13: 256,\n  ic09: 512,\n  ic14: 512,\n  ic10: 1024\n};\nfunction readImageHeader(buffer, imageOffset) {\n  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  return [\n    buffer.toString(\"ascii\", imageOffset, imageLengthOffset),\n    buffer.readUInt32BE(imageLengthOffset)\n  ];\n}\nfunction getImageSize(type) {\n  const size = ICON_TYPE_SIZE[type];\n  return { width: size, height: size, type };\n}\nconst ICNS = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 4) === \"icns\";\n  },\n  calculate(buffer) {\n    const bufferLength = buffer.length;\n    const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);\n    let imageOffset = SIZE_HEADER;\n    let imageHeader = readImageHeader(buffer, imageOffset);\n    let imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    if (imageOffset === fileLength) {\n      return imageSize;\n    }\n    const result = {\n      height: imageSize.height,\n      images: [imageSize],\n      width: imageSize.width\n    };\n    while (imageOffset < fileLength && imageOffset < bufferLength) {\n      imageHeader = readImageHeader(buffer, imageOffset);\n      imageSize = getImageSize(imageHeader[0]);\n      imageOffset += imageHeader[1];\n      result.images.push(imageSize);\n    }\n    return result;\n  }\n};\n\nconst J2C = {\n  validate(buffer) {\n    return buffer.toString(\"hex\", 0, 4) === \"ff4fff51\";\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32BE(12),\n      width: buffer.readUInt32BE(8)\n    };\n  }\n};\n\nconst BoxTypes = {\n  ftyp: \"66747970\",\n  ihdr: \"69686472\",\n  jp2h: \"6a703268\",\n  jp__: \"6a502020\",\n  rreq: \"72726571\",\n  xml_: \"786d6c20\"\n};\nconst calculateRREQLength = (box) => {\n  const unit = box.readUInt8(0);\n  let offset = 1 + 2 * unit;\n  const numStdFlags = box.readUInt16BE(offset);\n  const flagsLength = numStdFlags * (2 + unit);\n  offset = offset + 2 + flagsLength;\n  const numVendorFeatures = box.readUInt16BE(offset);\n  const featuresLength = numVendorFeatures * (16 + unit);\n  return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n  return {\n    height: box.readUInt32BE(4),\n    width: box.readUInt32BE(8)\n  };\n};\nconst JP2 = {\n  validate(buffer) {\n    const signature = buffer.toString(\"hex\", 4, 8);\n    const signatureLength = buffer.readUInt32BE(0);\n    if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n      return false;\n    }\n    const ftypeBoxStart = signatureLength + 4;\n    const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n    const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n    return ftypBox.toString(\"hex\", 0, 4) === BoxTypes.ftyp;\n  },\n  calculate(buffer) {\n    const signatureLength = buffer.readUInt32BE(0);\n    const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n    let offset = signatureLength + 4 + ftypBoxLength;\n    const nextBoxType = buffer.toString(\"hex\", offset, offset + 4);\n    switch (nextBoxType) {\n      case BoxTypes.rreq:\n        const MAGIC = 4;\n        offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      case BoxTypes.jp2h:\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      default:\n        throw new TypeError(\"Unsupported header found: \" + buffer.toString(\"ascii\", offset, offset + 4));\n    }\n  }\n};\n\nfunction readUInt(buffer, bits, offset, isBigEndian) {\n  offset = offset || 0;\n  const endian = isBigEndian ? \"BE\" : \"LE\";\n  const methodName = \"readUInt\" + bits + endian;\n  return buffer[methodName].call(buffer, offset);\n}\n\nconst EXIF_MARKER = \"45786966\";\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = \"4d4d\";\nconst LITTLE_ENDIAN_BYTE_ALIGN = \"4949\";\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n  return buffer.toString(\"hex\", 2, 6) === EXIF_MARKER;\n}\nfunction extractSize(buffer, index) {\n  return {\n    height: buffer.readUInt16BE(index),\n    width: buffer.readUInt16BE(index + 2)\n  };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n  const idfOffset = 8;\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES;\n    if (start > exifBlock.length) {\n      return;\n    }\n    const block = exifBlock.slice(start, end);\n    const tagNumber = readUInt(block, 16, 0, isBigEndian);\n    if (tagNumber === 274) {\n      const dataFormat = readUInt(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\nfunction validateExifBlock(buffer, index) {\n  const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n  const byteAlign = exifBlock.toString(\"hex\", EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\nfunction validateBuffer(buffer, index) {\n  if (index > buffer.length) {\n    throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");\n  }\n  if (buffer[index] !== 255) {\n    throw new TypeError(\"Invalid JPG, marker table corrupted\");\n  }\n}\nconst JPG = {\n  validate(buffer) {\n    const SOIMarker = buffer.toString(\"hex\", 0, 2);\n    return SOIMarker === \"ffd8\";\n  },\n  calculate(buffer) {\n    buffer = buffer.slice(4);\n    let orientation;\n    let next;\n    while (buffer.length) {\n      const i = buffer.readUInt16BE(0);\n      if (isEXIF(buffer)) {\n        orientation = validateExifBlock(buffer, i);\n      }\n      validateBuffer(buffer, i);\n      next = buffer[i + 1];\n      if (next === 192 || next === 193 || next === 194) {\n        const size = extractSize(buffer, i + 5);\n        if (!orientation) {\n          return size;\n        }\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      }\n      buffer = buffer.slice(i + 2);\n    }\n    throw new TypeError(\"Invalid JPG, no size found\");\n  }\n};\n\nconst SIGNATURE = \"KTX 11\";\nconst KTX = {\n  validate(buffer) {\n    return SIGNATURE === buffer.toString(\"ascii\", 1, 7);\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32LE(40),\n      width: buffer.readUInt32LE(36)\n    };\n  }\n};\n\nconst pngSignature = \"PNG\\r\\n\u001a\\n\";\nconst pngImageHeaderChunkName = \"IHDR\";\nconst pngFriedChunkName = \"CgBI\";\nconst PNG = {\n  validate(buffer) {\n    if (pngSignature === buffer.toString(\"ascii\", 1, 8)) {\n      let chunkName = buffer.toString(\"ascii\", 12, 16);\n      if (chunkName === pngFriedChunkName) {\n        chunkName = buffer.toString(\"ascii\", 28, 32);\n      }\n      if (chunkName !== pngImageHeaderChunkName) {\n        throw new TypeError(\"Invalid PNG\");\n      }\n      return true;\n    }\n    return false;\n  },\n  calculate(buffer) {\n    if (buffer.toString(\"ascii\", 12, 16) === pngFriedChunkName) {\n      return {\n        height: buffer.readUInt32BE(36),\n        width: buffer.readUInt32BE(32)\n      };\n    }\n    return {\n      height: buffer.readUInt32BE(20),\n      width: buffer.readUInt32BE(16)\n    };\n  }\n};\n\nconst PNMTypes = {\n  P1: \"pbm/ascii\",\n  P2: \"pgm/ascii\",\n  P3: \"ppm/ascii\",\n  P4: \"pbm\",\n  P5: \"pgm\",\n  P6: \"ppm\",\n  P7: \"pam\",\n  PF: \"pfm\"\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n  default: (lines) => {\n    let dimensions = [];\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line[0] === \"#\") {\n        continue;\n      }\n      dimensions = line.split(\" \");\n      break;\n    }\n    if (dimensions.length === 2) {\n      return {\n        height: parseInt(dimensions[1], 10),\n        width: parseInt(dimensions[0], 10)\n      };\n    } else {\n      throw new TypeError(\"Invalid PNM\");\n    }\n  },\n  pam: (lines) => {\n    const size = {};\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line.length > 16 || line.charCodeAt(0) > 128) {\n        continue;\n      }\n      const [key, value] = line.split(\" \");\n      if (key && value) {\n        size[key.toLowerCase()] = parseInt(value, 10);\n      }\n      if (size.height && size.width) {\n        break;\n      }\n    }\n    if (size.height && size.width) {\n      return {\n        height: size.height,\n        width: size.width\n      };\n    } else {\n      throw new TypeError(\"Invalid PAM\");\n    }\n  }\n};\nconst PNM = {\n  validate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 2);\n    return Signatures.includes(signature);\n  },\n  calculate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 2);\n    const type = PNMTypes[signature];\n    const lines = buffer.toString(\"ascii\", 3).split(/[\\r\\n]+/);\n    const handler = handlers[type] || handlers.default;\n    return handler(lines);\n  }\n};\n\nconst PSD = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 4) === \"8BPS\";\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32BE(14),\n      width: buffer.readUInt32BE(18)\n    };\n  }\n};\n\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n  height: /\\sheight=(['\"])([^%]+?)\\1/,\n  root: svgReg,\n  viewbox: /\\sviewBox=(['\"])(.+?)\\1/,\n  width: /\\swidth=(['\"])([^%]+?)\\1/\n};\nconst INCH_CM = 2.54;\nconst units = {\n  cm: 96 / INCH_CM,\n  em: 16,\n  ex: 8,\n  m: 96 / INCH_CM * 100,\n  mm: 96 / INCH_CM / 10,\n  pc: 96 / 72 / 12,\n  pt: 96 / 72\n};\nfunction parseLength(len) {\n  const m = /([0-9.]+)([a-z]*)/.exec(len);\n  if (!m) {\n    return void 0;\n  }\n  return Math.round(parseFloat(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n  const bounds = viewbox.split(\" \");\n  return {\n    height: parseLength(bounds[3]),\n    width: parseLength(bounds[2])\n  };\n}\nfunction parseAttributes(root) {\n  const width = root.match(extractorRegExps.width);\n  const height = root.match(extractorRegExps.height);\n  const viewbox = root.match(extractorRegExps.viewbox);\n  return {\n    height: height && parseLength(height[2]),\n    viewbox: viewbox && parseViewbox(viewbox[2]),\n    width: width && parseLength(width[2])\n  };\n}\nfunction calculateByDimensions(attrs) {\n  return {\n    height: attrs.height,\n    width: attrs.width\n  };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n  const ratio = viewbox.width / viewbox.height;\n  if (attrs.width) {\n    return {\n      height: Math.floor(attrs.width / ratio),\n      width: attrs.width\n    };\n  }\n  if (attrs.height) {\n    return {\n      height: attrs.height,\n      width: Math.floor(attrs.height * ratio)\n    };\n  }\n  return {\n    height: viewbox.height,\n    width: viewbox.width\n  };\n}\nconst SVG = {\n  validate(buffer) {\n    const str = String(buffer);\n    return svgReg.test(str);\n  },\n  calculate(buffer) {\n    const root = buffer.toString(\"utf8\").match(extractorRegExps.root);\n    if (root) {\n      const attrs = parseAttributes(root[0]);\n      if (attrs.width && attrs.height) {\n        return calculateByDimensions(attrs);\n      }\n      if (attrs.viewbox) {\n        return calculateByViewbox(attrs, attrs.viewbox);\n      }\n    }\n    throw new TypeError(\"Invalid SVG\");\n  }\n};\n\nfunction calculateExtended(buffer) {\n  return {\n    height: 1 + buffer.readUIntLE(7, 3),\n    width: 1 + buffer.readUIntLE(4, 3)\n  };\n}\nfunction calculateLossless(buffer) {\n  return {\n    height: 1 + ((buffer[4] & 15) << 10 | buffer[3] << 2 | (buffer[2] & 192) >> 6),\n    width: 1 + ((buffer[2] & 63) << 8 | buffer[1])\n  };\n}\nfunction calculateLossy(buffer) {\n  return {\n    height: buffer.readInt16LE(8) & 16383,\n    width: buffer.readInt16LE(6) & 16383\n  };\n}\nconst WEBP = {\n  validate(buffer) {\n    const riffHeader = buffer.toString(\"ascii\", 0, 4) === \"RIFF\";\n    const webpHeader = buffer.toString(\"ascii\", 8, 12) === \"WEBP\";\n    const vp8Header = buffer.toString(\"ascii\", 12, 15) === \"VP8\";\n    return riffHeader && webpHeader && vp8Header;\n  },\n  calculate(buffer) {\n    const chunkHeader = buffer.toString(\"ascii\", 12, 16);\n    buffer = buffer.slice(20, 30);\n    if (chunkHeader === \"VP8X\") {\n      const extendedHeader = buffer[0];\n      const validStart = (extendedHeader & 192) === 0;\n      const validEnd = (extendedHeader & 1) === 0;\n      if (validStart && validEnd) {\n        return calculateExtended(buffer);\n      } else {\n        throw new TypeError(\"Invalid WebP\");\n      }\n    }\n    if (chunkHeader === \"VP8 \" && buffer[0] !== 47) {\n      return calculateLossy(buffer);\n    }\n    const signature = buffer.toString(\"hex\", 3, 6);\n    if (chunkHeader === \"VP8L\" && signature !== \"9d012a\") {\n      return calculateLossless(buffer);\n    }\n    throw new TypeError(\"Invalid WebP\");\n  }\n};\n\nconst typeHandlers = {\n  bmp: BMP,\n  cur: CUR,\n  dds: DDS,\n  gif: GIF,\n  icns: ICNS,\n  ico: ICO,\n  j2c: J2C,\n  jp2: JP2,\n  jpg: JPG,\n  ktx: KTX,\n  png: PNG,\n  pnm: PNM,\n  psd: PSD,\n  svg: SVG,\n  webp: WEBP\n};\nconst getMimeType = (type) => {\n  if (type === \"svg\") {\n    return \"image/svg+xml\";\n  }\n  return `image/${type}`;\n};\n\nconst keys = Object.keys(typeHandlers);\nconst firstBytes = {\n  56: \"psd\",\n  66: \"bmp\",\n  68: \"dds\",\n  71: \"gif\",\n  73: \"tiff\",\n  77: \"tiff\",\n  82: \"webp\",\n  105: \"icns\",\n  137: \"png\",\n  255: \"jpg\"\n};\nfunction detector(buffer) {\n  const byte = buffer[0];\n  if (byte in firstBytes) {\n    const type = firstBytes[byte];\n    if (typeHandlers[type].validate(buffer)) {\n      return type;\n    }\n  }\n  const finder = (key) => typeHandlers[key].validate(buffer);\n  return keys.find(finder);\n}\n\nfunction lookup(buffer, filepath) {\n  const type = detector(buffer);\n  if (type && type in typeHandlers) {\n    const size = typeHandlers[type].calculate(buffer, filepath);\n    if (size !== void 0) {\n      size.type = type;\n      size.mimeType = getMimeType(type);\n      return size;\n    }\n  }\n  throw new TypeError(\"unsupported file type: \" + type + \" (file: \" + filepath + \")\");\n}\nfunction imageMeta(input) {\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  }\n  throw new Error(\"Input should be buffer!\");\n}\nconst types = Object.keys(typeHandlers);\n\nexports.imageMeta = imageMeta;\nexports.types = types;\n"],"sourceRoot":""}